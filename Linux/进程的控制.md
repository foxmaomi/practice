# 进程的控制

一、进程的创建

fork函数初始

1.头文件#include<unistd.h>   pid_t fork(void)

2.调用fork后内核做：分配新的内存块和内核数据结构给子进程->将父进程部分数据结构内容拷贝至子进程->添加子进程到系统进程列表中->fork返回，开始调度器调度。

3.fork之前父进程独立执行，fork之后，父子两个执行流分别执行，具体谁先执行完全由调度器决定。

fork函数的返回值

1.fork采用写时拷贝

fork常规用法

1.一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求。

2.一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数

fork调用失败的原因

1.系统中有太多的进程

2.实际用户的进程数超过了限制。

二、进程终止

进程退出场景

1.代码运行完毕，结果正确

2.代码运行完毕，结果不正确

3.代码异常终止。

进程常见退出方法

1.正常终止（可以通过echo $ ？ 查看进程代码）：

1.从main返回

2.调用exit

3._exit

异常退出：Ctrl+c 信号终止。

参数：status定义了进程的终止状态，父进程通过wait来获取该值

说明：虽然status是int，但是仅有低8位可以被父进程所用。所以_exit(-1)时，在终端执行发现函数是255

exit函数    #include <unistd.h> void exit(int status);

exit最后也会调用exit，但在调用exit之前，还做了其他工作：

1.执行用户通过atexit或on_exit定义的清理函数

2.关闭所有打开的流，所有的缓存数据均被写入

3.调用_exit 

return 退出：return是一种更常见的退出进程的方法。执行return 你等同于执行exit（n，因为调用main的运行时函数会将main的返回值当做exit的参数。

三、进程等待

进程等待必要性

1.之前讲过，子进程退出，父进程如果不管不顾，就可能就造成僵尸进程的问题，进而造成内存泄漏。

2.另外，进程一旦变成僵尸状态，那就刀枪不入。杀人不眨眼的kill-9也无能为力，因为谁也没有办法杀死一个已经死去的进程。

3.最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对或者是否正常退出。

4.父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息

四、进程等待的方法

1.wait方法

#include<sys/types.h>

#include<sys/wait.h>

pid_t wait(int *status); 

返回值：成功返回被等待进程pid,失败返回-1.

参数：输出型参数，获取子进程退出状态不关心则可以设置成为NULL。

2.waitpid方法

pid_t waitpid（pid_t pid,int *status, int options);

返回值：

当正常返回的时候waitpid返回收集到的子进程的进程ID；

如果设置选项WNOHANG，而调用中waitpid发现没有已退出的子进程可以收集，则返回0

如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；

参数：

pid：

pid=-1 ，等待一个子进程。与wait等效

pid>0. 等待其进程ID与pid相等的子进程。

status：

WIDEXITED（status）：若为正常终止子进程返回状态，则为真。（查看进程是否正常退出）

WEXITSTATUS（status）：若WIFEXITED 非零，提取子进程退出码。（查看进程的退出码）

options：

WNOHANG ：若pid指定的子进程没有结束，则waitpid（）函数返回0，不予以等待，若正常结束，则返回该进程的ID。